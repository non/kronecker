package kronecker

import spire.algebra.Rig

/**
 * Represents the cardinality of a set.
 *
 * Ideally, there would be two subtypes of Card: Finite and
 * Infinite. However, in practice we often find ourselves dealing with
 * cardinalities that are too large to compute but still finite
 * (e.g. 2^(2^100)). To support this, we have Semifinite values which
 * use a free representation (Plus, Times, and Pow) to represent
 * values that aren't infinite but which are too large to compute.
 *
 * We treat these values as "effectively infinite" in the sense that
 * we can't produce any index values large enough to exceed them.
 */
sealed trait Card { lhs =>

  import Card._

  def value: Option[Z] =
    this match {
      case Finite(n) => Some(n)
      case _ => None
    }

  def contains(i: Z): Boolean =
    if (i < 0) false
    else this match {
      case Finite(n) => i < n
      case _ => true
    }

  def isMax(i: Z): Boolean =
    this match {
      case Finite(n) => i == n - 1
      case _ => false
    }

  def +(rhs: Card): Card =
    (lhs, rhs) match {
      case (_, Infinite) => Infinite
      case (Infinite, _) => Infinite
      case (x: Semifinite, y: Semifinite) => plus(x, y)
    }

  // unsafe
  def -(rhs: Int): Card =
    (lhs, rhs) match {
      case (Finite(n), rhs) if Z(rhs) >= n => Card.zero
      case (Finite(n), rhs) => Finite(n - rhs)
      case (card, _) => card
    }

  def *(rhs: Card): Card =
    (lhs, rhs) match {
      case (Zero, _) => Zero
      case (_, Zero) => Zero
      case (_, Infinite) => Infinite
      case (Infinite, _) => Infinite
      case (x: Semifinite, y: Semifinite) => times(x, y)
    }

  def **(rhs: Card): Card =
    (lhs, rhs) match {
      case (_, Zero) => One
      case (Zero, _) => Zero
      case (_, One) => lhs
      case (One, _) => One
      case (_, Infinite) => Infinite
      case (Infinite, _) => Infinite
      case (x: Semifinite, y: Semifinite) => pow(x, y)
    }

  def partialCompare(rhs: Card): Double =
    (lhs, rhs) match {
      case (x, y) if x == y       =>  0.0
      case (_, Infinite)          => -1.0
      case (Infinite, _)          =>  1.0
      case (Finite(x), Finite(y)) => (x compare y).toDouble
      case (Finite(_), _)         => -1.0
      case (_, Finite(_))         =>  1.0
      case (_, _)                 => Double.NaN
    }
}

object Card {

  def apply(n: Z): Card = Finite(n)

  case object Infinite extends Card {
    override def toString: String = "âˆž"
  }

  // 2^6553400 has 1972770 decimal digits
  val MaxExponent: Z = Z(6553400)

  sealed abstract class Semifinite extends Card {
    override def toString: String =
      this match {
        case Finite(x) => x.toString
        case Plus(x, y) => s"($x + $y)"
        case Times(x, y) => s"($x * $y)"
        case Pow(x, y) => s"($x ** $y)"
      }
  }

  case class Plus(x: Semifinite, y: Semifinite) extends Semifinite
  case class Times(x: Semifinite, y: Semifinite) extends Semifinite
  case class Pow(x: Semifinite, y: Semifinite) extends Semifinite

  case class Finite private (size: Z) extends Semifinite {
    require(size >= 0)
  }

  val Zero: Finite = Finite(Z.zero)
  val One: Finite = Finite(Z.one)
  val Two: Finite = Finite(Z(2))

  def zero: Card = Zero
  def one: Card = One
  def two: Card = Two
  def infinite: Card = Infinite

  def plus(lhs: Semifinite, rhs: Semifinite): Semifinite =
    (lhs, rhs) match {
      case (Zero, _) => rhs
      case (_, Zero) => lhs
      case (Finite(x), Finite(y)) => Finite(x + y)
      case (Plus(x, y), z) => Plus(x, plus(y, z))
      case (Finite(x), Plus(Finite(y), z)) => Plus(Finite(x + y), z)
      case (x, y) => Plus(x, y)
    }

  def times(lhs: Semifinite, rhs: Semifinite): Semifinite =
    (lhs, rhs) match {
      case (Zero, _) => Zero
      case (_, Zero) => Zero
      case (One, _) => rhs
      case (_, One) => lhs
      case (Finite(x), Finite(y)) => Finite(x * y)
      case (Times(x, y), z: Semifinite) => Times(x, times(y, z))
      case (Finite(x), Times(Finite(y), z)) => Times(Finite(x * y), z)
      case (x, y) => Times(x, y)
    }

  def pow(lhs: Semifinite, rhs: Semifinite): Semifinite =
    (lhs, rhs) match {
      case (Finite(x), Finite(y)) => Card.semipow(x, y)
      case (_, Zero) => One
      case (Zero, _) => Zero
      case (_, One) => lhs
      case (One, _) => Zero
      case (Pow(x, y), z) => Pow(x, times(y, z))
      case (x: Semifinite, y: Semifinite) => Pow(x, y)
    }

  def semipow(base: Z, exponent: Z): Semifinite =
    if      (exponent.isZero)     Card.One
    else if (base.isZero)         Card.Zero
    else if (base.isOne)          Card.One
    else {
      // (2 ** k) approximates (base ** exponent)
      val k = exponent * base.bitLength
      if (k <= MaxExponent) Card.Finite(base.pow(exponent.toInt))
      else Pow(Card.Finite(base), Card.Finite(exponent))
    }

  implicit object CardAlgebra extends Rig[Card] {
    def zero: Card = Zero
    def one: Card = One
    def plus(x: Card, y: Card): Card = x + y
    def times(x: Card, y: Card): Card = x * y
  }
}
